\subsection{Deferred rendering}\label{sub:deferred rendering}
\paragraph{}

Silnik graficzny został napisany przy użyciu popularnej ostatnio techniki deferred rendering~\cite{gpugems:deferred}~\cite{calver:deferred}. Jest ona popularna dopiero od niedawana, ponieważ wymaga stosunkowo nowych i silnych kart graficznych. Pozwala jednak na dużą kontrolę nad procesem renderowania oraz umożliwia tworzenie ciekawych efektów graficznych w stosunkowo łatwy sposób. Bardzo dobrze sprawdza się również przy dużej ilości obiektów oraz otwartych przestrzeniach. Nadaje się zatem idealnie do wyświetlania układów planetarnych. Wybór tej techniki pozwolił także na optymalizację, dzięki której geometria w programie została ograniczona do niezbędnego minimum. Spowodowało to pewne dodatkowe koszty, jednak były one o wiele niższe niż w przypadku standardowego podejścia forward renderingu.

\paragraph{}

Deferred rendering polega na dwuprzejściowym generowaniu finalnego obrazu. W pierwszym przejściu, przeliczana jest geometria, a wynik tych obliczeń wpisywany jest do specjalnego bufora geometrii, nazywanego g-buforem. W g-buforze zapisywane są informacje o pozycji, normalnej oraz kolorze danego piksela ekranu. W zależności od danego silnika bufor ten może zawierać różne dane. W drugim przejściu, na podstawie tego bufora liczone są wszystkie efekty graficzne, takie jak oświetlenie, cienie, dla każdego piksela oddzielnie. Takie podejście pozwala na bardzo wiele oraz jest stosunkowo wydajne, posiada jednak wady. Poniżej przedstawione są wady jak i zalety deferred renderingu.

\paragraph{Zalety}

\begin{description}
\item{Skalowalność} - ponieważ ciężkie obliczenia liczone są dla piksela, silnik ten doskonale skaluje się zarówno ze względu na dodawanie geometrii do sceny, jak i na oddalanie i zbliżanie kamery do obiektów na scenie

\item{Duża kontrola} - dzięki jawnemu tworzeniu buforów ekranu, można stworzyć wiele niestandardowych efektów graficznych

\end{description}

\paragraph{Wady}

\begin{description}
\item{Wielkość buforów} - bufory ekranu zajmują bardzo dużo miejsca, przy rozdzielczości full hd może być to nawet 50MB, co dla starych kart graficznych było wielkościami ogromnymi
\item{Przezroczystość} - ponieważ obliczenia są robione tylko raz dla każdego piksela ekranu, niemożliwe jest zrobienie przezroczystości w ten sposób
\item{Dużo obliczeń} - niezależnie od sceny obliczenia są proporcjonalne do wielkości ekranu i robione dla piksela. Dla starych kart graficznych jest to o wiele za ciężkie rozwiązanie
\item{Wymagane MRT} - ponieważ buforów jest wiele, wymagana od karty jest technologia MRT, czyli multiple render target, dzięki której można wygenerować jednocześnie wszystkie bufory. Na starych kartach graficznych potrzebne było tyle przejść ile jest buforów, co powoduje wielokrotne obliczenia geometrii
\end{description}

\subsection{Układy planetarne i klasteryzacja}\label{sub:uklady planetarne}

\paragraph{}
Zadanie silnika fizycznego w najprostszym ujęciu nie jest zbyt skomplikowane. Musi on na bieżąco obliczać położenia planet, podczas gdy oddziałują na nie pozostałe planety. Zasadniczo złożoność takich obliczeń jest rzędu \ensuremath{O(n^2)} w każdej klatce fizyki. Siła oddziaływania planet między sobą jest opisana znanym z liceum wzorem:

		$$ \overrightarrow{F_{ij}} = G\frac{m_i m_j}{r^2}\overrightarrow{e_{ij}}  $$

gdzie: 

$ \overrightarrow{F_{ij}} $ - wektor siły działającej na ciało $i$ w wyniku oddziaływania z ciałem $j$. 

$ G $ - stała grawitacji. 
 
$ m_i $ - masa ciała $i$. 

$ r $ - odległość ciał $i$ oraz $j$. 

$ e_{ij} $ - wektor jednostkowy, skierowany od ciała $i$ do ciała $j$. 

\paragraph{}

Jak widać z powyższego wzoru, siła maleje wprost proporcjonalnie do $ \frac {1}{r^2} $. W praktyce oznacza to, że dla pojedynczych, odległych od siebie planet, siła oddziaływania jest pomijalnie niska. W związku z tym można podzielić przestrzeń na klastry, wewnątrz których liczone są wszystkie oddziaływania. Ponadto, liczone są także sumaryczne oddziaływania klastrów między sobą, a prędkość wypadkowa z tych oddziaływań jest dodawana do prędkości każdej z planet w klastrze.

\paragraph{}
Rozważmy złożoność obliczeniową jednej klatki fizyki przy podziale przestrzeni na klastry. Zakładamy, że $n$ planet podzielono na $k$ klastrów, przy czym każdy klaster zawiera $\frac{n}{k}$ planet. Ilość oddziaływań wewnątrz wszystkich klastrów wynosi:
$$ k\left(\frac{n}{k}\right)^2 = \frac{n^2}{k}$$

\paragraph{}
Należy także obliczyć oddziaływania pomiędzy całymi klastrami planet. Wyliczenie środków oraz sumarycznych mas klastrów wymaga
$$ k\frac{n}{k} = n $$

\paragraph{}
obliczeń. Oddziaływań klastrów między sobą jest natomiast
$$ k^2 $$

\paragraph{}
Po zsumowaniu otrzymujemy faktyczną złożoność algorytmu:
$$ O( \frac{n^2}{k} + n + k^2 ) = O( \frac{n^2}{k} + k^2 ) $$

W efekcie, jeżeli przyjmiemy liczbę klastrów równą $\sqrt[3]{n^2}$, złożoność wyniesie $O(n\sqrt[3]{n})$. W praktyce okazuje się, że jest to zbyt duża wartość. Wynika to m.in. z faktu, iż podział na klastry zwykle nie jest równomierny. Należy także pamiętać o narzucie obliczeniowym związanym z wyliczaniem samych klastrów, który został w powyższym rozumowaniu pominięty.

\paragraph{}
Do podziału przestrzeni planet na klastry używany jest algorytm k-means\cite{kmeans}. Jest to algorytm heurystyczny, przez co trudno jest szacować jego złożoność. W ogólnym przypadku problem klasteryzacji jest problemem NP-trudnym. Wynik oraz czas działania algorytmu k-means zależą znacząco od wyboru punktów początkowych. W naszym przypadku idealnymi punktami początkowymi są środki $k$ najcięższych planet, gdyż skupiają one wokół siebie inne, lżejsze ciała. Pozwala to na zadowalająco szybkie znajdowanie poprawnych klastrów przy użyciu tego algorytmu.
