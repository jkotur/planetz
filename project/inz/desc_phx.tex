\subsection{Oddziaływania}

\paragraph{}
Podstawą silnika fizycznego jest wykonywane równolegle obliczenie oddziaływań planet na siebie, odpowiednia modyfikacja prędkości, a następnie masy każdej z planet. Zrównoleglenie obliczeń jest w tym przypadku trywialne - każda planeta oblicza siły działające na nią samą, iterując kolejno po pozostałych planetach.

\subsection{Klastertyzacja}

\paragraph{} Do klasteryzacji używany jest alorytm k-means, a właściwie zrównoleglona jego wersja. Klastry definiowane są przez dwie tablice - \ensuremath{shuffle} oraz \ensuremath{count}. Do klastra o numerze k należą te planety, których indeksy znajdują się w tablicy \ensuremath{shuffle} pod indeksami z przedziału \ensuremath{< count[k-1], count[k] )}. Przyjmujemy, że \ensuremath{count[-1] = 0}.

\paragraph{} Taka reprezentacja pozwala na łatwe korzystanie z planet z danego klastra w module fizycznym i jest transparentna dla modułu graficznego.

\paragraph{} Równoległa wersja algorytmu k-means różni się nieco od wersji sekwencyjnej. Jako punkty startowe - początkowe środki klastrów - przyjmujemy położenia k najmasywniejszych obiektów. Dzięki temu już na początku jesteśmy dość blisko rozwiązania. Powodem tego jest fakt, że w wyniku oddziaływań fizycznych lżejsze obiekty będą skupiać się wokół cięższych. W każdej iteracji algorytmu najpierw znajdujemy każdej planecie środek klastra (równolegle dla każdej planety). W ten sposób powstaje tablica przypisań. Następnie inicjujemy - równolegle, rzecz jasna - tablicę $shuffle$ kolejnymi liczbami całkowitymi ($shuffle[i]=i$). Korzystając z biblioteki cudpp sortujemy obie tablice - kluczami do posortowania są przypisania kolejnych klastrów, natomiast wartościami - kolejne pola tablicy $shuffle$. W ten sposób dostajemy takie przemapowanie, jakie chcieliśmy. Pozostaje do obliczenia tablica $count$ - aby ją otrzymać, równolegle dla każdego elementu posortowanej tablicy przypisań, sprawdzamy, czy jego przypisanie różni się z przypisaniem sąsiednim. Jeżeli tak, oznacza to, że aktualny wątek jest ostatnim dla swojego klastra, wpisuje on więc swój indeks w tablicy $count$ pod indeksem równym numerowi klastra, do którego przynależy. Następnie pozostaje jedynie obliczyć nowe środki oraz błąd klasteryzacji (średnią odległość od środka klastra). Obie te operacje wykonywane są równolegle - standardowym algorytmem redukcji\cite{reduction}. Iteracje powtarzamy, aż stosunek zmiany błędu do samego błędu stanie się wystarczająco mały.

\subsection{Kolizje} w teorii rozwiązywane są prosto - jeżeli dwa obiekty zachodzą na siebie, należy je skleić. Algorytm sekwencyjny do tego celu sprawdzałby kolejne pary planet, usuwając te kolidujące ze sobą. Jeżeli jednak chcemy zrealizować obsługę kolizji równolegle, rozwiązanie naiwne okazuje się nie być prawidłowe. Gdyby każda planeta w osobnym wątku CUDA sprawdzała kolizje ze wszystkimi planetami po kolei, mogłoby dojść do konfliktów.

\paragraph{} Najpierw opiszę sposób, w jaki usuwamy planety. Przy każdej kolizji jedna planeta musi zostać usunięta, a druga staje się sumą fizyczną tych dwóch planet. Usuwanie planet przebiega dwuetapowo. Pierwszy etap - usunięcie logiczne, to zwykłe wyzerowanie masy oraz promienia usuwanej planety. Wyzerowanie masy powoduje, że planeta nie oddziałuje na inne, jest więc transparentna dla modułu fizyki. Wyzerowanie promienia natomiast "ukrywa" planetę przed modułem graficznym, który dzięki temu jej nie wyświetla. Dodatkowo, algorytm wykrywający kolizje ignoruje planety o zerowym promieniu.
Drugi etap usuwania - usunięcie fizyczne, powoduje przesunięcie wszystkich "istniejących" planet do początku tablicy - dla każdego parametru osobno. Realizowane jest to przy pomocy funkcji cudppCompact z biblioteki cudpp.
Wewnątrz tej funkcji używana jest funkcja cudppScan, która efektywnie zamienia tablicę zerojedynkową, odróżniającą planety nieusunięte od usuniętych, na tablicę indeksów, pod które należy skopiować te planety.

\paragraph{} Wracając do problemu z równoległością w rozwiązywaniu kolizji - w implementacji naiwnej mogłoby się zdarzyć tak, że dwie planety w tym samym czasie wykryłyby kolizję z trzecią planetą, obliczyłyby parametry wynikowej planety (każda ze sobą), po czym wyzerowałyby parametry tej planety. W efekcie kolidująca planeta zostałaby "zdublowana" - w szczególności jej masa dodałaby się do obu kolidujących z nią planet.

\paragraph{} Obsługa kolizji przebiega w efekcie dwuetapowo: pierwszy etap to wykrycie kolizji, drugi to ich rozwiązanie, czyli sklejanie kolidujących planet. Poza wymienionymi wyżej czynnikami należy wspomnieć o jeszcze jednym - o klasteryzacji. Kolizje rozwiązywane są jedynie wewnątrz klastrów, gdyż zakładamy, że prawdopodobieństwo kolizji planet z różnych klastrów jest pomijalnie niewielkie.

\paragraph{Detekcja kolizji} - definiujemy tablicę kolizji k. Jeżeli planeta i nie koliduje z żadną, \ensuremath{k[i] = i}. Jeżeli natomiast wykryła kolizję z planetą j, \ensuremath{k[i] = j}. Dodatkowo wymagamy, żeby relacja ta spełniała warunek \ensuremath{i\prec j} w pewnym porządku liniowym. Dzięki temu kolidujące planety nie utworzą cyklu.

\paragraph{} Kolizje rozwiązujemy wewnątrz klastra.  Z definicji tablicy shuffle wynika, że \ensuremath{i \neq j \Rightarrow shuffle[i]\neq shuffle[j]}. Wobec tego relacja \ensuremath{shuffle[i] \prec shuffle[j] \Leftrightarrow i<j } tworzy porządek liniowy.

\paragraph{} Detekcja przebiega następująco:
\begin{lstlisting}
merge_needed = false
foreach planet p in parallel
	id = p.index + 1
	while id < count[ p.cluster ]
		if( kolizja( p, planet[ shuffle[ id ] ] ) )
			merge_needed = true
			k[ shuffle[ p.id ] ] = shuffle[ id ]
			return;
		++id
	k[ shuffle[ p.id ] ] = shuffle[ p.id ]
\end{lstlisting}

\paragraph{} W efekcie dostajemy tablicę k. Jeżeli nie została ustawiona flaga merge\_needed, kończymy. Jeżeli została, zaczynamy sklejanie planet:
\begin{lstlisting}
done = false
k_in = k
while !done
	done = true
	foreach planet p in parallel	
		if( k_in[ p.id ] == p.id )
			k_out[ p.id ] = p.id
			return
		if( k_in[ k_in[ p.id ] ] != k_in[ p.id ] )
			k_out[ p.id ] = k_in[ p.id ]
			done = false
		merge( p, planet[ k_in[ p.id ] ] )
		k_out[ p.id ] = p.id
	k_in <=> k_out
\end{lstlisting}

\paragraph{} Po czym powtarzamy detekcję.
