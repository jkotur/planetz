\subsection{Silnik graficzny}\label{sub:silnik graficzny}
\subsubsection{Geometria}\label{ssub:geometria}
\paragraph{}

Największą zmianą w stosunku do dokumentacji technicznej dla silnika graficznego była zmiana podejścia do renderowania planet. Początkowo miał zostać użyty standardowy forward rendering, który wymaga siatek zarówno dla geometrii, jak i do tekstur. Po testach okazało się, że z powodów ograniczeń technicznych zastosowanie forward renderingu w takiej formie, w jakiej chcieliśmy, jest niemożliwe. Przeszkodą były ograniczenia karty graficznej, która pozwala na generowanie zaledwie około 100 wierzchołków przy pomocy geometry shaderów. Dla realistycznego wyglądu kuli potrzebne było natomiast przy zbliżeniach około 1000. Wszelkie podejścia wyświetlenia tak dużej geometrii prosto z karty graficznej były skazane na niepowodzenie. Dlatego użyto techniki deferred renderingu.
\paragraph{}
Powiązana zmiana dotyczy dynamicznego generowania geometrii. W pierwotnych założeniach siatki planet miały być generowane na różnym poziomie dokładności, następnie wyświetlana miała być właściwa dla danej planety. W podejściu deferred renderingu nie jest to konieczne, ponieważ obliczenia są robione dla każdego piksela. Oznacza to, że jeśli planeta widoczna jest jako kilka pikseli, obliczenia dla niej będą wykonywane tylko dla tych kilku pikseli. Deferred rendering w tym przypadku skaluje się idealnie i nie ma potrzeby poprawiania go.

\subsubsection{Pamięć}\label{ssub:pamiec}
\paragraph{}

Użycie deferred renderingu poniosło za sobą pewne zmiany w strukturze programu. Niepotrzebne okazały się wszelkie struktury odpowiedzialne za generowanie oraz przetrzymywanie geometrii. Konieczne natomiast stało się generowanie map normalnych oraz map atmosfery. Jednak to zadanie silnik graficzny realizuje sam. W efekcie zarządzanie pamięcią zostało znacznie uproszczone przy jednoczesnym skomplikowaniu silnika graficznego.

\subsubsection{Atmosfery}\label{ssub:atmosfery}
\paragraph{}

Pierwotnie atmosfery miały być półprzezroczystymi kulami otaczającymi planety. Ponieważ jednak zrezygnowaliśmy z forward renderingu, konieczna była zmiana i sposobu renderowania atmosfer. W wyniku naszych prac, atmosfery są wyświetlane w oddzielnym przejściu deferred renderingu, analogicznie do wyświetlania planet. Dokładny opis aktualnego algorytmu wyświetlającego atmosfery znajduje się w rozdziale \hyperref[sub:atmosfery]{\ref{sub:atmosfery}}.

\subsubsection{Komety}\label{ssub:komety}
\paragraph{}

Pierwotnie wśród planet miały znaleźć się również komety. Zostały one usunięte z projektu z dwóch powodów. Pierwszym jest zmiana sposobu wyświetlania planet. Pierwotnie komety miały być wyświetlane jako chmura cząstek lecących za planetą. Zmiana podejścia do wyświetlania planet sprawiła, że komety też powinny być wyświetlane inaczej. Kolejnym pomysłem było rysowanie półprzezroczystych ogonów za planetami. Ponieważ jednak deferred rendering bardzo źle radzi sobie z przezroczystościami, wyświetlanie komet wymagałoby bardzo dużych zmian w silniku graficznym. Drugim powodem jest kierunek ogona komety. Okazało się, że ogon komety nie ciągnie się, jak nam się wcześniej wydawało, za planetą, natomiast jest powodowany wiatrem słonecznym. W szczególności kometa oddalająca się od gwiazdy może mieć ogon skierowany w tym samym kierunku, w którym leci. Rozważaliśmy założenie, że ogon komety ciągnie się zawsze za kometą. Jednak naszym głównym celem jest jak najbardziej realistyczne oddanie układów planetarnych, dlatego takie założenie wydało nam się zbyt naiwne.

\paragraph{}

Poprawne generowanie ogonów komet wiązałoby się ze znacznym zwiększeniem ilości obliczeń. Należałoby również w znaczny sposób skomplikować silnik graficzny. Doprowadziłoby to do spowolnienia go. Obliczenia w silniku fizycznym musiałyby zostać podwojone. Ponieważ program działa na granicy czasu rzeczywistego dla dużych układów, zdecydowaliśmy się na wykluczenie efektu komet z finalnej wersji projektu. W zamian dodaliśmy moduł, który śledzi ruch planet, pozwalając obserwować ich trajektorię.

\subsection{Silnik fizyczny}\label{sub:silnik fizyczny}
\subsubsection{Kolizje}
\paragraph{}

Z powodu braku dobrego modelu fizycznego jedynym wynikiem kolizji jest w tej chwili sklejenie dwóch planet w jedną. Wynik takiego sklejenia ma masę równą sumie mas planet przed zderzeniem, objętość równą sumie objętości, oraz pęd równy sumie pędów - czyli wypadkowa prędkość powstałego tworu jest równa średniej ważonej prędkości zderzających się planet, z wagami równymi masom. Zależność tę widać poniżej:
\begin{align}
p_3 & = p_1 + p_2 \\
m_3 * V_3 & = m_1 * V_1 + m_2 * V_2 \\
( m_1 + m_2 ) * V_3 & = m_1 * V_1 + m_2 * V_2 \\
V_3 & = \frac{ m_1 * V_1 + m_2 * V_2 }{ m_1 + m_2 }
\end{align}

\subsubsection{Organizacja kodu}

\paragraph{}

Główną zmianą w module fizycznym w stosunku do dokumentacji technicznej jest brak wspólnego interfejsu CudaAlgorithm. Pojawiła się natomiast klasa Clusterer, dzieląca przestrzeń na klastry. Konieczność jej wydzielenia wynikała ze złożoności kodu implementującego algorytm k-means.

Pewną zmianą jest także rezygnacja z przestrzeni nazw CPU2GPU oraz FILE2CPU. Zmieniona została również nazwa Holder na PlanetHolder - jako kontener służący do przechowywania informacji o planetach. Stało się tak dla odróżnienia go od ClusterHoldera przechowującego bufory z informacjami o klastrach.



