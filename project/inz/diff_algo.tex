\subsection{Silnik graficzny}\label{sub:silnik graficzny}
\subsubsection{Geometria}\label{ssub:geometria}
\paragraph{}

Największą zmianą dla silnika graficznego była zmiana podejścia renderowania planet. W pierwotnych założeniach użyty miał zostać standardowy forward rendering, który wymaga siatek zarówno dla geometrii, jak i do tekstur. Po testach, okazało się że z powodów ograniczeń technicznych zastosowanie forward renderingu w takiej formie w jakiej chcieliśmy jest niemożliwe. Przeszkodą były ograniczenia karty graficznej, która pozwala na generowanie zaledwie około 100 wierzchołków przy pomocy geometry shaderów. Dla realistycznego wyglądu kuli potrzebne było natomiast przy zbliżeniach około 1000. Wszelkie podejścia wyświetlenia tak dużej geometrii prosto z karty graficznej, były skazane na niepowodzenie. Dlatego zdecydowaliśmy się na użycie techniki nazywanej deferred renderingiem. Ma ona te zalety że skaluje się bardzo dobrze dla wielu obiektów, oraz można było przy jej pomocy uzyskać realistyczne kule bez dużej ilości geometrii w programie. Wadami takiego rozwiązania są dość duże koszty, związane ze sporymi buforami ekranu, oraz obliczeniami per-piksel. Dodatkowo na starszych kartach bez MTR (Multiple Render Targets), są dodatkowe nakłady związane z wymuszonym robieniem kilku przejść. W efekcie silnik graficzny, aby działać wydajnie potrzebuje dość nowych kart graficznych, co i tak było wymuszone przez użycie CUDA w silniku fizycznym.

\paragraph{}

Powiązana zmiana z wyżej wymienioną dotyczy dynamicznego generowania geometrii. W pierwotnych założeniach siatki planet miały być generowane na różnym poziomie dokładności, następnie wyświetlana miała być właściwa dla danej planety. W podejściu deferred renderingu nie jest to konieczne, ponieważ obliczenia są robione dla każdego piksela. Oznacza to, że jeśli planeta widoczna jest jako kilka pikseli, obliczenia dla niej będą wykonywane tylko dla tych kilku pikseli. Deferred rendering w tym przypadku skaluje się idealnie, i nie ma potrzeby poprawiania go.

\subsubsection{Pamięć}\label{ssub:pamiec}
\paragraph{}

Użycie deferred renderingu poniosło za sobą pewne zmiany w strukturze programu. Niepotrzebne okazały się wszelkie struktury odpowiedzialne za generowanie, oraz przetrzymywanie geometrii. Konieczne natomiast stało się generowanie map normalnych, oraz map atmosfery. Jednak to zadanie silnik graficzny realizuje sam, dlatego w efekcie zarządzanie pamięcią się uprościło, na rzecz skomplikowania silnika graficznego.

\subsubsection{Atmosfery}\label{ssub:atmosfery}
\paragraph{}

Pierwotnie atmosfery miały być półprzezroczystymi kulami otaczającymi planety. Ponieważ jednak zrezygnowaliśmy z forward renderingu, konieczna była zmiana i sposobu renderowania atmosfer. W wyniku naszych prac, atmosfery są wyświetlane w oddzielnym przejściu deferred renderingu, bardzo analogicznie do wyświetlania planet.

\subsubsection{Komety}\label{ssub:komety}
\paragraph{}

Pierwotne założenie pracy inżynierskiej było takie, że wśród planet znajdą się również komety. Zostały one usunięte z projektu z dwóch powodów. Pierwszym jest zmiana sposobu wyświetlania planet. Pierwotnie komety miały być wyświetlane jako chmura cząstek lecących za planetą. Zmiana podejścia do wyświetlania planet sprawiła że komety też powinny być wyświetlane inaczej. Kolejnym pomysłem było rysowanie półprzezroczystych ogonów za planetami. Ponieważ jednak deferred rendering bardzo źle radzi sobie z przezroczystościami, trzeba by robić duże zmiany w silniku graficznym aby móc wyświetlić komety. Drugim powodem jest kierunek ogona komety. Okazało się że ogon komety nie ciągnie się, jak nam się wcześniej wydawało, za planetą, natomiast jest powodowany wiatrem słonecznym. W szczególności kometa oddalająca się od gwiazdy, może mieć ogon w tym samym kierunku w którym leci. Zastanawialiśmy się czy nie oszukać i nie generować ogonów komet za kometami, tak jak się popularnie sądzie. Jednak naszym głównym celem było realistyczne oddanie układów planetarnych, dlatego takie oszustwo wydało nam się zbyt duże i zbyt mylące.

\paragraph{}

W efekcie poprawne generowanie ogonów komet spowodowałoby bardzo znaczne obliczenia. Należały by bardzo skomplikować silnik graficzny, co nie odbyło by się bez dodatkowego spowolnienia go, oraz tak naprawdę podwoić obliczenia w silniku fizycznym. Ponieważ już teraz program działa na granicy czasu rzeczywistego dla dużych układów, zdecydowaliśmy się na wykluczenie efektu komet z finalnej wersji projektu. W zamian dodaliśmy moduł który śledzi ruch planet, pozwalając obserwować ich trajektorię.

\subsection{Silnik fizyczny}\label{sub:silnik fizyczny}
\subsubsection{Kolizje}
\paragraph{}

Z powodu braku dobrego modelu fizycznego jedynym wynikiem kolizji jest w tej chwili sklejenie dwóch planet w jedną. Wynik takiego sklejenia ma masę równą sumie mas planet przed zderzeniem, objętość równą sumie objętości, oraz pęd równy sumie pędów - czyli wypadkowa prędkość powstałego tworu jest równa średniej ważonej prędkości zderzających się planet, z wagami równymi masom.

Zależność tę widać poniżej:
\begin{align}
p_3 & = p_1 + p_2 \\
m_3 * V_3 & = m_1 * V_1 + m_2 * V_2 \\
( m_1 + m_2 ) * V_3 & = m_1 * V_1 + m_2 * V_2 \\
V_3 & = \frac{ m_1 * V_1 + m_2 * V_2 }{ m_1 + m_2 }
\end{align}

\subsubsection{Organizacja kodu}

\paragraph{}

Główną zmianą w module fizycznym w stosunku do dokumentacji technicznej jest brak wspólnego interfejsu CudaAlgorithm. Pojawiła się natomiast klasa Clusterer, dzieląca przestrzeń na klastry. Konieczność jej wydzielenia wynikała ze złożoności kodu implementującego algorytm k-means.

Pewną zmianą jest także rezygnacja z przestrzeni nazw CPU2GPU oraz FILE2CPU. Zmieniona została również nazwa Holder na PlanetHolder - jako kontener służący do przechowywania informacji o planetach. Stało się tak dla odróżnienia go od ClusterHoldera przechowującego bufory z informacjami o klastrach.



